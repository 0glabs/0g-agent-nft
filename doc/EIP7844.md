---
eip: 7844 
title: An NFT Standard for AI Agents with Private Metadata
description: A standard interface for AI agent NFTs, enabling secure management of private metadata with verifiable data transfer
author: 
discussions-to: 
status: Draft 
type: Standards Track 
category: ERC 
created: 2024-12-26 
requires: 165
---

## Abstract

A standard interface for NFTs specifically designed for AI agents, where the metadata represents agent capabilities and requires privacy protection. Unlike traditional NFT standards that focus on static metadata, this standard introduces mechanisms for verifiable data ownership and secure transfer. By defining a unified interface for different verification methods (e.g., TEE, ZKP), it enables secure management of valuable agent metadata such as models, memory, and character definitions, while maintaining confidentiality and verifiability.

## Motivation

With the increasing intelligence of AI models, agents have become powerful tools for automating meaningful daily tasks. The integration of agents with blockchain technology has been recognized as a major narrative in the crypto industry, with many projects enabling agent creation for their users. However, a crucial missing piece is the decentralized management of agent ownership.

AI agents possess inherent non-fungible properties that make them natural candidates for NFT representation:

1. Each agent is unique, with its own model, memory, and character
2. Agents embody clear ownership rights, representing significant computational investment and intellectual property
3. Agents have private metadata (e.g., neural network models, memory, character definitions) that defines their capabilities

However, current NFT standards like ERC-721 are insufficient for representing AI agents effectively. The key challenge lies in the metadata transfer mechanism. Unlike traditional NFTs where metadata is typically static and publicly accessible, an agent's metadata:

1. Has intrinsic value and is often the primary purpose of the transfer
2. Requires encrypted storage to protect intellectual property
3. Needs privacy-preserving and verifiable transfer mechanisms when ownership changes

For example, when transferring an agent NFT, we need to ensure:

1. The actual transfer of encrypted metadata is verifiable
2. The new owner can securely access the metadata
3. The agent's execution environment can verify ownership and load appropriate metadata

This EIP introduces a standard for NFTs with private metadata that addresses these requirements through privacy-preserving verification mechanisms, enabling secure ownership and transfer of valuable agent data while maintaining confidentiality and verifiability. This standard will serve as a foundation for the emerging agent ecosystem, allowing platforms to provide verifiable agent ownership and secure metadata management in a decentralized manner.

## Specification

The EIP defines three key interfaces: the main NFT interface (IERC7844), the metadata interface (IERC7844Metadata), and the data verification interface (IERC7844DataVerifier).

### Data Verification System

The verification system consists of two core components that work together to ensure secure data operations:

1. **On-chain Verifier (IERC7844DataVerifier)**
   - Implemented as a smart contract
   - Verifies proofs submitted through contract calls
   - Returns structured verification results
   - Can be implemented using different verification mechanisms (TEE/ZKP)

2. **Off-chain Prover**
   - Generates proofs for ownership and availability claims
   - Works with encrypted data and keys
   - Implementation varies based on verification mechanism:
     * TEE-based: Generates proofs within trusted hardware
     * ZKP-based: Creates cryptographic zero-knowledge proofs

The system supports two types of proofs:

1. **Ownership Proof**
   - Generated by Prover with access to original data
   - Proves knowledge of pre-images for claimed dataHashes
   - Verified on-chain through verifyOwnership()

2. **Availability Proof**
   - Generated by Prover for data transfers
   - Proves:
     * Knowledge of original data (pre-images)
     * Correct decryption and re-encryption of data
     * Secure key transmission (using receiver's public key to encrypt the new key)
     * Data availability in storage (using receiver's signature to confirm the data is available in storage)
   - Verified on-chain through verifyAvailable()

The ownership verification is optional because when the minted token is transferred or cloned, the ownership verification is checked again inside the availability verification. But for better safe than sorry, we recommend using ownership verification for minting and updates.

Different verification mechanisms have distinct capabilities:

- **TEE-based Implementation**
  * Prover runs in trusted hardware
  * Can handle private keys securely
  * Enables direct data re-encryption
  * Verifier checks TEE attestations

- **ZKP-based Implementation**
  * Prover generates cryptographic proofs
  * Cannot handle multi-party private keys
  * Re-encryption key known to prover
  * Requires additional re-encryption when next update, otherwise the new update is still visible to the prover

### Data Verification Interface

```solidity
struct OwnershipProofOutput {
    bytes32[] dataHashes;
    bool isValid;
}

struct AvailabilityProofOutput {
    bytes32[] oldDataHashes;
    bytes32[] newDataHashes;
    bytes pubKey;
    bytes sealedKey;
    bool isValid;
}

interface IERC7844DataVerifier {
    /// @notice Verify ownership of data
    /// @param _proof Proof generated by companion prover system
    /// @return Verification result and validated data hashes
    function verifyOwnership(
        bytes calldata _proof
    ) external view returns (OwnershipProofOutput memory);

    /// @notice Verify data availability and transfer validity
    /// @param _proof Proof generated by companion prover system
    /// @return Verification result and transfer details
    function verifyAvailable(
        bytes calldata _proof
    ) external view returns (AvailabilityProofOutput memory);
}
```

### Metadata Interface

```solidity
interface IERC7844Metadata {
    /// @dev This emits when data is updated
    event Updated(
        uint256 indexed _tokenId,
        bytes32[] _oldDataHashes,
        bytes32[] _newDataHashes
    );

    /// @dev This emits when a user is added to the user group
    event AddedToGroup(
        uint256 indexed _tokenId,
        address indexed _user
    );

    /// @notice Get the name of the NFT collection
    function name() external view returns (string memory);

    /// @notice Get the symbol of the NFT collection
    function symbol() external view returns (string memory);

    /// @notice Get the config metadata for the NFT collection
    /// @return storageURL The base storage URL for the functional data
    function config() external view returns (
        string memory storageURL
    );

    /// @notice Set the config metadata (only owner)
    function setConfig(
        string memory storageURL
    ) external;

    /// @notice Get the metadata URI for a specific token
    function tokenURI(uint256 tokenId) external view returns (string memory);

    /// @notice Update data
    /// @param _tokenId The token to update
    /// @param _proof Proof of updated data ownership
    function update(
        uint256 _tokenId,
        bytes calldata _proof
    ) external;

    /// @notice Get the data hash of a token
    /// @param _tokenId The token identifier
    /// @return The current data hash of the token
    function dataHashesOf(uint256 _tokenId) external view returns (bytes32[] memory);
}

```

### Main NFT Interface

```solidity
interface IERC7844 {
    /// @dev This emits when a new functional NFT is minted
    event Minted(
        uint256 indexed _tokenId,
        address indexed _creator,
        bytes32[] _dataHashes
    );

    /// @dev This emits when data is transferred with ownership
    event Transferred(
        uint256 _tokenId,
        address indexed _from,
        address indexed _to
    );

    /// @dev This emits when data is cloned
    event Cloned(
        uint256 indexed _tokenId,
        uint256 indexed _newTokenId,
        address _from,
        address _to
    );

    /// @dev This emits when a sealed key is published
    event PublishedSealedKey(
        address indexed _to,
        uint256 indexed _tokenId,
        bytes _sealedKey
    );

    /// @notice The verifier interface that this NFT uses
    /// @return The address of the verifier contract
    function verifier() external view returns (IERC7844DataVerifier);

    /// @notice Mint new NFT with data ownership proof
    /// @param _proof Proof of data ownership   
    /// @return _tokenId The ID of the newly minted token
    function mint(bytes calldata _proof)
        external
        payable
        returns (uint256 _tokenId);

    /// @notice Transfer full data (full means data and ownership)
    /// @param _to Address to transfer data to
    /// @param _tokenId The token to transfer data for
    /// @param _proof Proof of data available for _to
    function transfer(
        address _to,
        uint256 _tokenId,
        bytes calldata _proof
    ) external;

    /// @notice Clone data (clone means just data, not ownership)
    /// @param _to Address to clone data to
    /// @param _tokenId The token to clone data for
    /// @param _proof Proof of data available for _to
    /// @return _newTokenId The ID of the newly cloned token
    function clone(
        address _to,
        uint256 _tokenId,
        bytes calldata _proof
    ) external payable returns (uint256 _newTokenId);

    /// @notice Transfer public data with ownership
    /// @param _to Address to transfer data to
    /// @param _tokenId The token to transfer data for
    function transferPublic(
        address _to,
        uint256 _tokenId
    ) external;

    /// @notice Clone public data
    /// @param _to Address to clone data to
    /// @param _tokenId The token to clone data for
    /// @return _newTokenId The ID of the newly cloned token
    function clonePublic(
        address _to,
        uint256 _tokenId
    ) external payable returns (uint256 _newTokenId);

    /// @notice Add authorized user to group
    /// @param _tokenId The token to add to group
    function authorizeUsage(
        uint256 _tokenId,
        address _user
    ) external;

    /// @notice Get token owner
    /// @param _tokenId The token identifier
    /// @return The current owner of the token
    function ownerOf(uint256 _tokenId) external view returns (address);

    /// @notice Get the authorized users of a token
    /// @param _tokenId The token identifier
    /// @return The current authorized users of the token
    function authorizedUsersOf(uint256 _tokenId) external view returns (address[] memory);
}
```

## Rationale

The design choices in this standard are motivated by several key requirements:

1. **Verification Abstraction**: The standard separates the verification logic into a dedicated interface (IERC7844DataVerifier), allowing different verification mechanisms (TEE, ZKP) to be implemented and used interchangeably. The verfier should support two types of proof:
    - Ownership Proof Verifies that the prover possesses the original data by demonstrating knowledge of the pre-images that generate the claimed dataHashes
    - Availability Proof Verifies secure data transfer and availability by proving: knowledge of the original data (pre-images of oldDataHashes); ability to decrypt with oldKey and re-encrypt with newKey; secure transmission of newKey using recipient's public key; integrity of the newly encrypted data matching newDataHashes; and data availability confirmed by recipient's signature on both oldDataHashes and newDataHashes
2. **Data Protection**: The standard uses data hashes and encrypted keys to ensure that valuable NFT data remains protected while still being integrity and availability verifiable

3. **Flexible Data Management**: Three distinct data operations are supported:
    - Full transfer, where the data and ownership are transferred to the new owner
    - Data cloning, where the data is cloned to a new token but the ownership is not transferred
    - Data usage authorization, where the data is authorized to be used by a specific user, but the ownership is not transferred, and the user still cannot access the data. This need an environment to authenticate the user and process the request from the authorized user secretly, we call it "Sealed Executor"
    
4. **Sealed Executor**: Although the Sealed Executor is not defined and out of the scope of this standard, it is a crucial component for the standard to work. The Sealed Executor is an environment that can authenticate the user and process the request from the authorized user secretly. The Sealed Executor should get authorized group by tokenId, and the verify the signature of the user using the public keys in the authorized group. If the verification is successful, the executor will process the request and return the result to the user, and the sealed executor could be implemented by a trusted party (where permitted), TEE, or FHE

## Backwards Compatibility

This EIP does not inherit from existing NFT standards to maintain its focus on functional data management. However, implementations can choose to additionally implement ERC-721 if traditional NFT compatibility is desired.

## Reference Implementation

```solidity
abstract contract BaseVerifier is IERC7844DataVerifier {
    // prevent replay attack
    mapping(bytes32 => bool) internal usedProofs;
    
    // check and mark proof used
    function _checkAndMarkProof(bytes32 proofHash) internal {
        require(!usedProofs[proofHash], "Proof already used");
        usedProofs[proofHash] = true;
    }
}

contract TEEVerifier is BaseVerifier {
    address public immutable attestationContract;
    
    constructor(address _attestationContract) {
        attestationContract = _attestationContract;
    }

    /// @notice Verify ownership of data, the _proof prove: 
    ///         1. The pre-image of dataHashes
    /// @param proof Proof generated by TEE
    function verifyOwnership(
        bytes calldata proof
    ) external view override returns (OwnershipProofOutput memory) {
        // TODO: Implement actual verification logic
        return OwnershipProofOutput(new bytes32[](0), true);
    }

    /// @notice Verify data availability, the _proof prove: 
    ///         1. The pre-image of oldDataHashes
    ///         2. The oldKey can decrypt the pre-image and the new key re-encrypt the plaintexts to new ciphertexts
    ///         3. The newKey is encrypted using the receiver's pubKey
    ///         4. The hashes of new ciphertexts is newDataHashes (key to note: TEE could support a private key of the receiver)
    ///         5. The newDataHashes identified ciphertexts are available in the storage: need the signature from the receiver signing oldDataHashes and newDataHashes
    /// @param proof Proof generated by TEE
    function verifyAvailable(
        bytes calldata proof
    ) external view override returns (AvailabilityProofOutput memory) {
        // TODO: Implement actual verification logic
        return AvailabilityProofOutput(new bytes32[](0), new bytes32[](0), bytes("null"), bytes("null"), true);
    }
}

contract AgentNFT is IERC7844, IERC7844Metadata {
   struct TokenData {
       address owner;
       bytes32[] dataHashes;
       address[] authorizedUsers;
   }
   
   IERC7844DataVerifier private immutable _verifier;
   mapping(uint256 => TokenData) private _tokens;
   uint256 private _nextTokenId;

   string private _name;
   string private _symbol;
   string private _storageURL;
   address private immutable _owner;
   
   constructor(
       string memory name_,
       string memory symbol_,
       address verifierAddr,
       string memory storageURL_
   ) {
       require(verifierAddr != address(0), "Zero address");
       _verifier = IERC7844DataVerifier(verifierAddr);
       _name = name_;
       _symbol = symbol_;
       _storageURL = storageURL_;
       _owner = msg.sender;
   }

   function name() external view returns (string memory) {
       return _name;
   }

   function symbol() external view returns (string memory) {
       return _symbol;
   }

   function config() external view returns (string memory) {
       return _storageURL;
   }

   function setConfig(string memory storageURL) external {
       require(msg.sender == _owner, "Not owner");
       _storageURL = storageURL;
   }

   function tokenURI(uint256 tokenId) external view returns (string memory) {
       require(_exists(tokenId), "Token does not exist");
       return string(abi.encodePacked(_storageURL));
   }

   function update(
       uint256 tokenId,
       bytes calldata proof
   ) external {
       TokenData storage token = _tokens[tokenId];
       require(token.owner == msg.sender, "Not owner");
       
       OwnershipProofOutput memory proofOupt = _verifier.verifyOwnership(proof);
       bytes32[] memory newDataHashes = proofOupt.dataHashes;
       require(
           proofOupt.isValid,
           "Invalid ownership proof"
       );

       bytes32[] memory oldDataHashes = token.dataHashes;
       token.dataHashes = newDataHashes;

       emit Updated(tokenId, oldDataHashes, newDataHashes);
   }
   
   function dataHashesOf(uint256 tokenId) external view returns (bytes32[] memory) {
       TokenData storage token = _tokens[tokenId];
       require(token.owner != address(0), "Token not exist");
       return token.dataHashes;
   }

   function verifier() external view returns (IERC7844DataVerifier) {
       return _verifier;
   }
   
   function mint(bytes calldata proof) 
       external 
       payable 
       returns (uint256 tokenId) 
   {
       OwnershipProofOutput memory proofOupt = _verifier.verifyOwnership(proof);
       bytes32[] memory dataHashes = proofOupt.dataHashes;
       require(
           proofOupt.isValid,
           "Invalid ownership proof"
       );

       tokenId = _nextTokenId++;
       _tokens[tokenId] = TokenData({
           owner: msg.sender,
           dataHashes: dataHashes,
           authorizedUsers: new address[](0)
       });
       
       emit Minted(tokenId, msg.sender, dataHashes);
   }

   function transfer(
       address to,
       uint256 tokenId,
       bytes calldata proof
   ) external {
       require(to != address(0), "Zero address");
       
       TokenData storage token = _tokens[tokenId];
       require(token.owner == msg.sender, "Not owner");
       
       AvailabilityProofOutput memory proofOupt = _verifier.verifyAvailable(proof);
       bytes32[] memory oldDataHashes = proofOupt.oldDataHashes;
       bytes32[] memory newDataHashes = proofOupt.newDataHashes;
       bytes32[] memory tokenDataHashes = token.dataHashes;
       bytes memory pubKey = proofOupt.pubKey;
       bytes memory sealedKey = proofOupt.sealedKey;
       
       require(
           proofOupt.isValid 
           && _isEqual(oldDataHashes, tokenDataHashes)
           && _pubKeyToAddress(pubKey) == to,
           "Invalid availability proof"
       );

       token.owner = to;
       token.dataHashes = newDataHashes;

       emit Transferred(tokenId, msg.sender, to);
       emit PublishedSealedKey(to, tokenId, sealedKey);
   }

   function transferPublic(
       address to,
       uint256 tokenId
   ) external {
       require(to != address(0), "Zero address");
       require(_tokens[tokenId].owner == msg.sender, "Not owner");
       _tokens[tokenId].owner = to;
       emit Transferred(tokenId, msg.sender, to);
   }

   function clone(
       address to,
       uint256 tokenId,
       bytes calldata proof
   ) external payable returns (uint256) {
       require(to != address(0), "Zero address");
       
       require(_tokens[tokenId].owner == msg.sender, "Not owner");
       
       AvailabilityProofOutput memory proofOupt = _verifier.verifyAvailable(proof);
       bytes32[] memory oldDataHashes = proofOupt.oldDataHashes;
       bytes32[] memory newDataHashes = proofOupt.newDataHashes;
       bytes32[] memory tokenDataHashes = _tokens[tokenId].dataHashes;
       bytes memory pubKey = proofOupt.pubKey;  
       bytes memory sealedKey = proofOupt.sealedKey;
       
       require(
           proofOupt.isValid 
           && _isEqual(oldDataHashes, tokenDataHashes)
           && _pubKeyToAddress(pubKey) == to,
           "Invalid availability proof"
       );

       uint256 newTokenId = _nextTokenId++;
       _tokens[newTokenId] = TokenData({
           owner: to,
           dataHashes: newDataHashes,
           authorizedUsers: new address[](0)
       });

       emit Cloned(tokenId, newTokenId, msg.sender, to);
       emit PublishedSealedKey(to, newTokenId, sealedKey);
       return newTokenId;
   }

   function clonePublic(
       address to,
       uint256 tokenId
   ) external payable returns (uint256) {
       require(to != address(0), "Zero address");
       require(_tokens[tokenId].owner == msg.sender, "Not owner");
       
       uint256 newTokenId = _nextTokenId++;
       _tokens[newTokenId] = TokenData({
           owner: to,
           dataHashes: _tokens[tokenId].dataHashes,
           authorizedUsers: new address[](0)
       });
       emit Cloned(tokenId, newTokenId, msg.sender, to);
       return newTokenId;
   }

   function authorizeUsage(uint256 tokenId, address user) external {
       require(_tokens[tokenId].owner == msg.sender, "Not owner");
       _tokens[tokenId].authorizedUsers.push(user);
       emit AuthorizedUsage(tokenId, user);
   }

   function ownerOf(uint256 tokenId) external view returns (address) {
       TokenData storage token = _tokens[tokenId];
       require(token.owner != address(0), "Token not exist");
       return token.owner;
   }

   function authorizedUsersOf(uint256 tokenId) external view returns (address[] memory) {
       TokenData storage token = _tokens[tokenId];
       require(token.owner != address(0), "Token not exist");
       return token.authorizedUsers;
   }
}
```

## Security Considerations

1. **Proof Verification**
    - Implementations must carefully verify all assertions in the proof
    - Replay attacks must be prevented
    - Different verfication systems have their own security considerations, and distinct capabilities regarding key management: TEE can securely handle private keys from multi-parties, enabling direct data re-encryption. However, ZKP, due to its cryptographic nature, cannot process private keys from multi-parties. As a result, the re-encryption key is also from the prover (i.e., the sender), so tokens acquired through transfer or cloning must undergo re-encryption during their next update, otherwise the new update is still visible to the previous owner. This distinction in key handling capabilities affects how data transformations are managed during later usage
2. **Data Privacy**
    - Only hashes and sealed keys are stored on-chain, actual functional data must be stored and transmitted securely off-chain
    - Key management is crucial for secure data access
    - TEE verification system could support private key of the receiver, but ZKP verification system could not. So when using ZKP, the token transfered or cloned from other should be re-encrypted when next update, otherwise the new update is still visible to the previous owner
3. **Access Control and State Managementl**
    - Operations restricted to token owners only
    - All data operations must maintain integrity and availability
    - Critical state changes (sealed keys, ownership, permissions) must be atomic and verifiable
4. **Sealed Executor**
    - Although out of scope for this standard, the Sealed Executor is crucial for secure operation
    - The Sealed Executor authenticates users and processes requests in a secure environment by verifying user signatures against authorized public keys for each tokenId
    - The Sealed Executor can be implemented through a trusted party (where permitted), Trusted Execution Environment (TEE), or Fully Homomorphic Encryption (FHE)
    - Ensuring secure request processing and result delivery

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).